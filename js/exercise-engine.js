// js/exercise-engine.js - Refactored
// Depends on:
// - js/music-theory.js (for MusicTheory, CHORD_TYPES)
// - js/engines/base-engine.js (for MusicTheoryEngine)
// - js/engines/note-engine.js (for NoteIdentificationEngine)
// - js/engines/interval-engine.js (for IntervalIdentificationEngine)
// - js/engines/scale-engine.js (for ScalePracticeEngine)
// - js/engines/chord-engine.js (for ChordIdentificationEngine, ChordBuildingEngine)

class ExerciseEngine {
    constructor(audioEngine, piano) { // Dependencies like audioEngine, piano can be passed if needed by engines
        this.audioEngine = audioEngine; // Will be needed for audio playback via exerciseData
        this.piano = piano; // May be needed for visual feedback or direct interaction by some engines

        this.availableEngines = new Map();
        this.initializeEngines();

        this.currentEngine = null; // Instance of the currently active engine
        this.exerciseData = null;  // Data for the current exercise, generated by an engine
        this.isActive = false;
        this.startTime = null;
        this.attempts = 0;
        this.maxAttempts = 3; // Default, can be overridden by exercise data if needed

        this.sessionStats = {
            exercisesCompleted: 0,
            correctAnswers: 0,
            totalAttempts: 0,
            averageTime: 0,
            accuracy: 0
        };

        this.curriculum = this.initializeCurriculum();
        this.currentLevel = this.loadProgress() || 1;
        this.pendingLevelUpNotification = null;

        console.log('Exercise Engine (Refactored) initialized');
    }

    initializeEngines() {
        // Check if engine classes are loaded
        if (typeof NoteIdentificationEngine !== 'undefined') {
            this.availableEngines.set('note-identification', new NoteIdentificationEngine());
        } else { console.error("NoteIdentificationEngine not loaded."); }

        if (typeof IntervalIdentificationEngine !== 'undefined') {
            this.availableEngines.set('interval-identification', new IntervalIdentificationEngine());
        } else { console.error("IntervalIdentificationEngine not loaded."); }

        if (typeof ScalePracticeEngine !== 'undefined') {
            this.availableEngines.set('scale-practice', new ScalePracticeEngine());
        } else { console.error("ScalePracticeEngine not loaded."); }

        if (typeof ChordIdentificationEngine !== 'undefined') {
            this.availableEngines.set('chord-identification', new ChordIdentificationEngine());
        } else { console.error("ChordIdentificationEngine not loaded."); }
        
        if (typeof ChordBuildingEngine !== 'undefined') {
            this.availableEngines.set('chord-building', new ChordBuildingEngine());
        } else { console.error("ChordBuildingEngine not loaded."); }
        
        // Add more engines here as they are created
        console.log(`${this.availableEngines.size} engines registered.`);
    }

    initializeCurriculum() {
        // Curriculum now refers to engine keys (exerciseType)
        // Options for each exercise type can be specified here to be passed to engine.generateExercise(options)
        return {
            1: {
                name: "Intro to Notes",
                // Exercises array now lists the keys for availableEngines
                exercises: [{ type: 'note-identification', options: { question: "What's that note?", numOptions: 3, octavesPool: [4] }}],
                requiredAccuracy: 0.7,
                minExercises: 5,
            },
            2: {
                name: "Basic Notes & Accidentals",
                exercises: [{ type: 'note-identification', options: { includeAccidentals: true, octavesPool: [3, 4, 5] } }],
                requiredAccuracy: 0.7,
                minExercises: 10
            },
            3: {
                name: "Basic Intervals",
                exercises: [
                    { type: 'interval-identification', options: { 
                        intervalsPool: [
                            { name: 'Major 2nd', semitones: 2 }, { name: 'Major 3rd', semitones: 4 }, 
                            { name: 'Perfect 5th', semitones: 7 }, { name: 'Perfect Octave', semitones: 12 }
                        ],
                        rootOctavesPool: [3,4]
                    }}
                ],
                requiredAccuracy: 0.7,
                minExercises: 10,
            },
            4: {
                name: "More Intervals",
                exercises: [{ type: 'interval-identification', options: { rootOctavesPool: [2,3,4,5] } }], // Use default full interval pool from engine
                requiredAccuracy: 0.75,
                minExercises: 15
            },
            5: {
                name: "Major Scales",
                exercises: [{ type: 'scale-practice', options: { scaleTypesPool: ['major'], startOctavesPool: [3,4] } }],
                requiredAccuracy: 0.8,
                minExercises: 10,
            },
            6: {
                name: "Minor Scales",
                exercises: [{ type: 'scale-practice', options: { scaleTypesPool: ['natural_minor', 'harmonic_minor'], startOctavesPool: [3,4] } }],
                requiredAccuracy: 0.8,
                minExercises: 10,
            },
            7: {
                name: "Triad ID (Major/Minor)",
                exercises: [{ type: 'chord-identification', options: { 
                    chordCategoriesPool: ['triads'], // Restrict to triads
                    // Further restrict specific triad types if needed by modifying CHORD_TYPES clone for options
                    // For simplicity, engine will pick from all triads if not further specified.
                    // Or, engine's generateExercise could accept a specific list of allowed chord names/symbols.
                }}],
                requiredAccuracy: 0.8,
                minExercises: 15,
            },
            8: {
                name: "Triad Building (Major/Minor)",
                exercises: [{ type: 'chord-building', options: { chordCategoriesPool: ['triads'] } }],
                requiredAccuracy: 0.8,
                minExercises: 15,
            },
            // Add more levels, potentially mixing exercise types within a level
            9: {
                name: "Mixed Review 1",
                exercises: [
                    { type: 'note-identification', options: {includeAccidentals: true} },
                    { type: 'interval-identification' },
                    { type: 'scale-practice', options: { scaleTypesPool: ['major', 'natural_minor']}}
                ],
                requiredAccuracy: 0.8,
                minExercises: 12
            },
            10: {
                name: "All Triads & Basic 7ths (ID)",
                exercises: [
                    { type: 'chord-identification', options: { chordCategoriesPool: ['triads', 'sevenths'] } } 
                    // Consider adding option to filter specific 7ths, e.g. only Dom7, Maj7
                ],
                requiredAccuracy: 0.85,
                minExercises: 20
            },
            11: {
                name: "Building 7th Chords",
                exercises: [{ type: 'chord-building', options: { chordCategoriesPool: ['sevenths'] } }],
                requiredAccuracy: 0.85,
                minExercises: 15,
            },
            12: {
                name: "Comprehensive Practice",
                exercises: [ // All available types, default options from engines
                    { type: 'note-identification' }, 
                    { type: 'interval-identification' }, 
                    { type: 'scale-practice' }, 
                    { type: 'chord-identification' }, 
                    { type: 'chord-building' }
                ],
                requiredAccuracy: 0.9,
                minExercises: 25
            }
        };
    }

    startExercise() {
        if (this.isActive) {
            // Potentially end current exercise formally if needed
            console.warn("Ending active exercise to start a new one.");
        }

        const currentLevelConfig = this.curriculum[this.currentLevel];
        if (!currentLevelConfig || !currentLevelConfig.exercises || currentLevelConfig.exercises.length === 0) {
            console.error(`No exercises defined for current level ${this.currentLevel} or level configuration is missing.`);
            this.currentEngine = null;
            this.exerciseData = null;
            this.isActive = false;
            return false; // Cannot start exercise
        }

        // Select an exercise type and its options from the current level's config
        const exerciseEntry = currentLevelConfig.exercises[Math.floor(Math.random() * currentLevelConfig.exercises.length)];
        const exerciseTypeKey = exerciseEntry.type;
        const exerciseOptions = exerciseEntry.options || {};

        this.currentEngine = this.availableEngines.get(exerciseTypeKey);

        if (!this.currentEngine) {
            console.error(`Engine not found for exercise type: ${exerciseTypeKey}`);
            this.exerciseData = null;
            this.isActive = false;
            return false; // Cannot start exercise
        }

        try {
            // Pass per-exercise options from curriculum to the engine's generator
            this.exerciseData = this.currentEngine.generateExercise(exerciseOptions);
            // Ensure exerciseData includes common fields expected by app.js for rendering
            // (e.g., question, options for MCQ, instruction for performance)
            // The individual engines are responsible for formatting this.
        } catch (error) {
            console.error(`Error generating exercise with engine ${exerciseTypeKey}:`, error);
            this.exerciseData = null;
            this.isActive = false;
            return false;
        }
        
        if (!this.exerciseData) {
            console.error(`Engine ${exerciseTypeKey} failed to generate exercise data.`);
            this.isActive = false;
            return false;
        }

        this.isActive = true;
        this.startTime = Date.now();
        this.attempts = 0;
        // maxAttempts could be part of exerciseData if it varies by exercise.
        this.maxAttempts = this.exerciseData.maxAttempts || 3;

        // For app.js: currentExercise is now the key, exerciseData holds the details.
        // The 'type' field in exerciseData (e.g., 'note-identification') is crucial for UI rendering logic in app.js
        this.currentExercise = exerciseTypeKey; // Keep this for app.js to know the type of exercise

        return true; // Successfully started
    }

    submitAnswer(userInput) {
        if (!this.isActive || !this.currentEngine || !this.exerciseData) {
            return { isCorrect: false, message: "Exercise not active or data missing.", action: 'error' };
        }

        this.attempts++;
        this.sessionStats.totalAttempts++;

        let isCorrect = false;
        try {
            isCorrect = this.currentEngine.validateAnswer(userInput, this.exerciseData);
        } catch (error) {
            console.error(`Error validating answer with engine ${this.currentEngine.getExerciseTypeName()}:`, error);
            return { isCorrect: false, message: "Error during answer validation.", action: 'error' };
        }
        
        if (isCorrect) {
            return this.handleCorrectAnswer(userInput);
        } else {
            return this.handleIncorrectAnswer(userInput);
        }
    }

    handleCorrectAnswer(userInput) {
        const timeSpent = Date.now() - this.startTime;
        this.sessionStats.exercisesCompleted++;
        this.sessionStats.correctAnswers++;
        this.updateAverageTime(timeSpent);
        this.updateAccuracy();
        this.saveProgress();

        let feedback = {
            isCorrect: true,
            message: `âœ… Correct! (${this.attempts} ${this.attempts === 1 ? 'attempt' : 'attempts'})`,
            action: 'proceedToNext',
            // Include theory snippet if available from the engine/exerciseData
            theorySnippet: this.currentEngine.getTheorySnippet(this.exerciseData) || (this.exerciseData ? this.exerciseData.theorySnippet : null)
        };

        // For performance exercises, include played vs expected notes if engine provides them
        if (this.exerciseData.expectedNotes && (this.currentEngine.getExerciseTypeName() === 'scale-practice' || this.currentEngine.getExerciseTypeName() === 'chord-building')) {
            feedback.playedNotes = userInput; // Assuming userInput is the array of played notes
            feedback.expectedNotes = this.exerciseData.expectedNotes;
        }
        
        return feedback;
    }

    handleIncorrectAnswer(userInput) {
        let feedbackBase = {
            isCorrect: false,
            attemptsLeft: this.maxAttempts - this.attempts,
            theorySnippet: this.currentEngine.getTheorySnippet(this.exerciseData) || (this.exerciseData ? this.exerciseData.theorySnippet : null)
        };

        if (this.exerciseData.expectedNotes && (this.currentEngine.getExerciseTypeName() === 'scale-practice' || this.currentEngine.getExerciseTypeName() === 'chord-building')) {
            feedbackBase.playedNotes = userInput;
            feedbackBase.expectedNotes = this.exerciseData.expectedNotes;
        }

        const correctAnswerDetail = Array.isArray(this.exerciseData.correctAnswer) ? this.exerciseData.correctAnswer.join(', ') : this.exerciseData.correctAnswer;

        if (this.attempts >= this.maxAttempts) {
            return {
                ...feedbackBase,
                message: `âŒ The correct answer was: ${correctAnswerDetail}. ${this.exerciseData.explanation || ''}`,
                action: 'proceedToNext',
                correctAnswerDetails: this.exerciseData.correctAnswer, // For UI highlighting
                explanation: this.exerciseData.explanation,
            };
        } else {
            return {
                ...feedbackBase,
                message: `âŒ Try again. ${this.maxAttempts - this.attempts} attempts left.`,
                action: 'retry',
            };
        }
    }

    nextExercise() {
        this.pendingLevelUpNotification = null;
        this.checkLevelProgression(); 

        const notification = this.pendingLevelUpNotification;
        this.pendingLevelUpNotification = null;

        // startExercise() is now called by app.js after user clicks "Next Exercise"
        // This method now primarily handles logic *before* starting the next one,
        // like checking for level up. The actual start is initiated by app.js.
        // We return the notification data for app.js to handle.
        
        // The actual call to this.startExercise() will be done by app.js
        // This method's role is reduced in the refactored flow.
        // For now, we'll assume app.js will call startExercise() after this.
        // So, this method just returns level up data.
        return notification; 
    }
    
    checkLevelProgression() {
        const currentLevelConfig = this.curriculum[this.currentLevel];
        if (!currentLevelConfig) return; // Should not happen if curriculum is well-defined

        const nextLevel = this.currentLevel + 1;
        
        if (this.sessionStats.exercisesCompleted >= (currentLevelConfig.minExercises || 1) && // Ensure minExercises is defined
            this.sessionStats.accuracy >= (currentLevelConfig.requiredAccuracy || 0) &&   // Ensure requiredAccuracy is defined
            this.curriculum[nextLevel]) {
            
            this.currentLevel = nextLevel;
            this.pendingLevelUpNotification = this.getLevelUpNotificationData();
            this.saveProgress(); // Save new level
        }
    }

    getLevelUpNotificationData() {
        const newLevelData = this.curriculum[this.currentLevel];
        const message = newLevelData ? 
            `ðŸŽ‰ Level Up! Welcome to Level ${this.currentLevel}: ${newLevelData.name}! New challenges await!` :
            `ðŸŽ‰ Level Up! Welcome to Level ${this.currentLevel}!`;
        return {
            isLevelUp: true,
            level: this.currentLevel,
            message: message
        };
    }

    // Progress management - unchanged from original
    updateAverageTime(timeSpent) {
        if (this.sessionStats.exercisesCompleted <= 0) return;
        const totalTime = (this.sessionStats.averageTime * (this.sessionStats.exercisesCompleted -1)) + timeSpent;
        this.sessionStats.averageTime = totalTime / this.sessionStats.exercisesCompleted;
    }

    updateAccuracy() {
        if (this.sessionStats.totalAttempts === 0) {
            this.sessionStats.accuracy = 0;
            return;
        }
        this.sessionStats.accuracy = this.sessionStats.correctAnswers / this.sessionStats.totalAttempts;
    }

    saveProgress() {
        try {
            const progress = {
                currentLevel: this.currentLevel,
                sessionStats: this.sessionStats, // Save the whole stats object
                lastSession: Date.now()
            };
            localStorage.setItem('musicTrainingProgress', JSON.stringify(progress));
        } catch (e) {
            console.error("Error saving progress to localStorage:", e);
        }
    }

    loadProgress() {
        try {
            const saved = localStorage.getItem('musicTrainingProgress');
            if (saved) {
                const progress = JSON.parse(saved);
                // Restore session stats as well if needed, or reset them for a new session
                // For now, just restoring level. Stats are typically per-session.
                // If we want to persist stats across sessions, load them here:
                // this.sessionStats = progress.sessionStats || this.sessionStats; 
                return progress.currentLevel || 1;
            }
        } catch (e) {
            console.error("Error loading progress from localStorage:", e);
        }
        return 1; // Default to level 1
    }
    
    // Public API methods - unchanged or slightly adapted
    getCurrentLevel() {
        return this.currentLevel;
    }

    getSessionStats() {
        return { ...this.sessionStats }; // Return a copy
    }

    // getCurrentExerciseData and getCurrentExerciseType are now implicitly handled
    // by app.js reading this.exerciseData and this.currentExercise (which is the type key)

    getCurrentLevelData() {
        return this.curriculum[this.currentLevel] || null;
    }

    resetProgressToLevel1() {
        this.currentLevel = 1;
        // Reset session stats for a clean start at level 1
        this.sessionStats = {
            exercisesCompleted: 0,
            correctAnswers: 0,
            totalAttempts: 0,
            averageTime: 0,
            accuracy: 0
        };
        this.saveProgress(); // Save the reset state
        console.log('Progress reset to Level 1 and session stats cleared.');
    }

    // getAvailableExercises might not be needed if curriculum drives exercise selection.
    // If needed, it could list engines available for the current level.
}

// Export for use in other modules or make global
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ExerciseEngine;
} else if (typeof window !== 'undefined') {
    window.ExerciseEngine = ExerciseEngine;
}
